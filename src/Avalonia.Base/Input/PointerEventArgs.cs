using System;
using System.Collections.Generic;
using Avalonia.Input.Raw;
using Avalonia.Interactivity;
using Avalonia.VisualTree;

namespace Avalonia.Input
{
    /// <summary>
    /// Arguments for input element's pointer related events.
    /// </summary>
    public class PointerEventArgs : RoutedEventArgs
    {
        private readonly IVisual? _rootVisual;
        private readonly Point _rootVisualPosition;
        private readonly Lazy<IReadOnlyList<RawPointerPoint>?>? _previousPoints;

        public PointerEventArgs(RoutedEvent routedEvent,
            IInteractive? source,
            IPointer pointer,
            IVisual? rootVisual, Point rootVisualPosition,
            ulong timestamp,
            PointerPointProperties properties,
            KeyModifiers modifiers)
           : base(routedEvent)
        {
            Source = source;
            _rootVisual = rootVisual;
            _rootVisualPosition = rootVisualPosition;
            Properties = properties;
            Pointer = pointer;
            Timestamp = timestamp;
            KeyModifiers = modifiers;
        }
        
        public PointerEventArgs(RoutedEvent routedEvent,
            IInteractive? source,
            IPointer pointer,
            IVisual? rootVisual, Point rootVisualPosition,
            ulong timestamp,
            PointerPointProperties properties,
            KeyModifiers modifiers,
            Lazy<IReadOnlyList<RawPointerPoint>?>? previousPoints)
            : this(routedEvent, source, pointer, rootVisual, rootVisualPosition, timestamp, properties, modifiers)
        {
            _previousPoints = previousPoints;
        }

        /// <summary>
        /// Gets specific pointer generated by input device.
        /// </summary>
        public IPointer Pointer { get; }

        /// <summary>
        /// Gets the time when the input occurred.
        /// </summary>
        public ulong Timestamp { get; }

        /// <summary>
        /// Gets a value that indicates which key modifiers were active at the time that the pointer event was initiated.
        /// </summary>
        public KeyModifiers KeyModifiers { get; }

        /// <summary>
        /// Gets the pointer position relative to a control.
        /// </summary>
        /// <param name="relativeTo">The control.</param>
        /// <returns>The pointer position in the visual's coordinates or null if not possible to transform to it.</returns>
        public Point? GetPosition(IVisual? relativeTo)
        {
            if (_rootVisual is null)
                return null;
            if (relativeTo is null)
                return _rootVisualPosition;

            var transform = _rootVisual.TransformToVisual(relativeTo);
            if (transform is null)
                return null;

            return _rootVisualPosition * transform;
        }

        /// <summary>
        /// Gets the pointer position relative to the input root.
        /// </summary>
        /// <returns>The pointer position in the root's coordinates.</returns>
        public Point GetPosition()
        {
            return _rootVisualPosition;
        }

        /// <summary>
        /// Returns the PointerPoint associated with the current event.
        /// </summary>
        /// <param name="relativeTo">The visual which coordinate system to use. Pass null for toplevel coordinate system</param>
        /// <returns>
        /// The Returns current point in the visual's coordinates or null if not possible to transform to relative visual. 
        /// </returns>
        public PointerPoint? GetCurrentPoint(IVisual? relativeTo)
            => GetPosition(relativeTo) is { } position
            ? new PointerPoint(Pointer, position, Properties)
            : null;

        /// <summary>
        /// Returns the PointerPoint associated with the current event.
        /// </summary>
        /// <returns>
        /// Returns current point in the root's coordinates. 
        /// </returns>
        public PointerPoint GetCurrentPoint()
            => new PointerPoint(Pointer, _rootVisualPosition, Properties);

        /// <summary>
        /// Retrieves position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
        /// </summary>
        /// <param name="relativeTo">The visual which coordinate system to use. Pass null for toplevel coordinate system</param>
        /// <returns>
        /// Returns list of the intermediate points including current point in the end.
        /// If it's not possible to transform points to the relative visual method returns an empty array.
        /// </returns>
        public IReadOnlyList<PointerPoint> GetIntermediatePoints(IVisual? relativeTo)
        {
            if (_rootVisual is null)
                return Array.Empty<PointerPoint>();

            var transform = Matrix.Identity;
            if (relativeTo is not null)
            {
                if (_rootVisual.TransformToVisual(relativeTo) is { } transformMatrix)
                {
                    transform = transformMatrix;
                }
                else
                {
                    return Array.Empty<PointerPoint>();
                }
            }

            var currentPoint = new PointerPoint(Pointer, _rootVisualPosition * transform, Properties);

            var previousPoints = _previousPoints?.Value;            
            if (previousPoints == null || previousPoints.Count == 0)
                return new[] { currentPoint };

            var points = new PointerPoint[previousPoints.Count + 1];
            for (var c = 0; c < previousPoints.Count; c++)
            {
                var pt = previousPoints[c];
                var pointProperties = new PointerPointProperties(Properties, pt);
                points[c] = new PointerPoint(Pointer, pt.Position * transform, pointProperties);
            }

            points[points.Length - 1] = currentPoint;
            return points;
        }

        /// <summary>
        /// Returns the current pointer point properties
        /// </summary>
        protected PointerPointProperties Properties { get; private set; }
    }
    
    public enum MouseButton
    {
        None,
        Left,
        Right,
        Middle,
        XButton1,
        XButton2
    }

    public class PointerPressedEventArgs : PointerEventArgs
    {
        public PointerPressedEventArgs(
            IInteractive source,
            IPointer pointer,
            IVisual rootVisual, Point rootVisualPosition,
            ulong timestamp,
            PointerPointProperties properties,
            KeyModifiers modifiers,
            int clickCount = 1)
            : base(InputElement.PointerPressedEvent, source, pointer, rootVisual, rootVisualPosition,
                timestamp, properties, modifiers)
        {
            ClickCount = clickCount;
        }

        public int ClickCount { get; }
    }

    public class PointerReleasedEventArgs : PointerEventArgs
    {
        public PointerReleasedEventArgs(
            IInteractive source, IPointer pointer,
            IVisual rootVisual, Point rootVisualPosition, ulong timestamp,
            PointerPointProperties properties, KeyModifiers modifiers,
            MouseButton initialPressMouseButton)
            : base(InputElement.PointerReleasedEvent, source, pointer, rootVisual, rootVisualPosition,
                timestamp, properties, modifiers)
        {
            InitialPressMouseButton = initialPressMouseButton;
        }

        /// <summary>
        /// Gets the mouse button that triggered the corresponding PointerPressed event
        /// </summary>
        public MouseButton InitialPressMouseButton { get; }
    }

    public class PointerCaptureLostEventArgs : RoutedEventArgs
    {
        public IPointer Pointer { get; }

        public PointerCaptureLostEventArgs(IInteractive source, IPointer pointer) : base(InputElement.PointerCaptureLostEvent)
        {
            Pointer = pointer;
            Source = source;
        }
    }
}
